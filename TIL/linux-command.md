# Linux Command
'리눅스 커맨드라인 완벽 입문서'라는 책을 보면서 중요하다고 생각하는 부분만 정리해놓은 자료입니다. 명령어와 그 역할에 대해서 간단하게만 기술했고, 실전에서 리눅스를 다뤄보며 디테일하게 보충할 예정입니다.


### 파일, 디렉토리 조작 관련
- cp : 복사 (copy)
- mv : 이동, 이름 바꾸기 (move)
- mkdir : 디렉토리 생성 (make a directory)
- rm : 삭제 (remove)

옵션
- -i, --interactive : 어떤 작업을 수행하기 전 동의를 구하겠다.
- -r, --recursive : 디렉토리와 그 안의 파일, 내용까지 포함하겠다.
- -v, --verbose : 명령어 수행을 완료했다는 메세지를 보여주겠다.


### 파이프라인
명령어의 출력을 또 다른 명령어의 입력과 연결시킬 수 있는 기능이다. 흔하게 사용하는 `grep`를 떠올리면 쉽다. 예를 들어 history 중에 mysql이 포함된 command만 보고 싶다면, history | grep mysql 라고 입력하면 된다. 이 때, history의 출력을 파이프라인을 이용해 grep의 입력과 연결시킨 것이다. 

현재 폴더 내 하위 폴더/파일 중 이름에 work가 포함된 항목의 갯수를 구하고 싶다면? 아래와 같이 파이프라인을 이용하면 쉽게 해결할 수 있다.
```
ls -al | grep work | wc -l 
```

### head와 tail
출력의 처음 몇 줄 또는 끝의 몇 줄만 확인하고 싶을 때 사용하는 명령어다. -n 옵션을 통해 출력할 라인 수를 지정할 수도 있다. 
```
tail -n 5 output.txt
```

`tail` 명령어는 실시간으로 파일을 확인할 수 있는 옵션을 지원한다. 로그 파일이 기록되는 동안 최근 내용을 확인하고 싶은 상황에서 사용하면 편리하다. follow라는 의미의 f옵션을 주면 된다.
```
tail -f output.txt
```

### I/O 리다이렉션
입력과 출력에 대한 방향을 재지정하는 방법이다. 예를 들어 ls 커맨드의 결과를 txt파일에 저장하고 싶다면? 아래와 같이 커맨드를 입력하면 ls 커맨드의 결과가 list.txt 파일에 저장된다. (파일이 존재하지 않으면 자동 생성)
```
ls -al > list.txt
```

연산자는 기본적으로 출력할 대상 파일의 값을 덮어쓴다. 이 때는 > 대신 `>>` 연산자를 사용해서 덧붙이면 된다.

오류 메세지의 경우 > 연산자로 출력이 불가능하다. 어떤 이유로 `2>` 연산자를 사용하라고 한다. 

기본 출력 및 오류를 한 번에 출력하고 싶다면 `&>` 연산자를 사용하면 된다.


### cat 
cat 명령어는 concatenate, 연결하다의 줄임말이다. cat은 단순히 텍스트 출력의 용도로 사용하는 커맨드인 줄 알았다. 어원을 알고, 책을 보니 확실히 짚고 넘어가야겠다.

아래와 같이 입력하면 a.txt와 b.txt의 내용을 이어서 보여준다.
```
cat a.txt b.txt 
```

대용량 파일이 분산되서 저장되어 있는 경우, 아래와 같이 입력하면 분산된 파일을 하나로 합칠 수 있다. (실제로 해보진 않았다)
```
cat movie.mpeg.0* > movie.mpeg
```

### 기타
- type : 커맨드의 종류 표시
- which : 실행 파일의 위치 표시
- alias : 명령어 만들기


