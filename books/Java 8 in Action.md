# Java 8 in Action
> 한빛미디어, 라울-게이브리얼 우르마 / 마리오 푸스코 / 앨런 마이크로프트 지음, 우정은 옮김

#### 책을 읽은 동기
Java 8이 릴리즈된지 벌써 4~5년이 지났지만, Java 8에 제대로 알고 있는 지식이 하나도 없었습니다. 이 책을 읽고 Java 8의 `등장 배경`, `추가된 API`를 중심으로 학습해보고자 이 책을 읽었습니다.


---------


## Java 8은 왜 등장했는가? 

### 기존 Java는 데이터를 병렬로 처리하기 어려웠다

기존 Java는 컬렉션의 데이터들을 병렬로 처리하려면 먼저 데이터들을 분할하고, 분할된 각 데이터의 처리를 각각의 쓰레드로 할당해서 결과를 합쳐야 합니다(마치 분할정복처럼). 이 과정을 기존 Java에서는 Fork/Join Framework를 이용해서 구현했습니다. 하지만 Java8에서는 병렬 스트림(Parallel Stream)을 이용해서 훨씬 쉽게 구현할 수 있습니다.

> 하지만 쉽게 구현할 수 있다는 것이 올바르게 사용할 수 있다는 말과 같지 않음을 알아야 합니다. 병렬스트림은 코어간 데이터 교환이나 스트림의 분할 등의 추가적인 비용이 발생합니다. 다시 말해 올바르게 사용하지 못하면 오히려 배보다 배꼽이 더 큰 상황이 있을 수 있습니다.


### 기존 Java는 보일러 플레이트 코드가 너무 많았다

Java의 익명클래스를 사용하는 경우 보일러플레이트 코드가 너무 많았습니다. 아레 코드를 보면, 기존 Java의 경우 sort의 비교 전략을 인자로 넘길 때 매우 복잡한 방식으로 코드를 작성해야 합니다. Java 8에서는 함수를 일급객체로 사용하기 때문에 람다, 메소드 레퍼런스를 활용하면 상대적으로 가독성이 높은 코드를 작성할 수 있습니다.

```java
// 보일러 플레이트 코드가 많은 Java 코드
Arrays.asList(1, 2, 3, 4).sort(new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return Integer.compare(o1, o2);
    }
});

// 개선된 Java 코드
Arrays.asList(1, 2, 3, 4).sort(Integer::compare);
```


### 기존 Java는 모두 명령형으로 코드를 작성했다

컬렉션에서 특정 조건에 부합하는 원소들을 추출하고, 추출된 원소들의 ID를 List로 재구성하고자 할 때 기존의 Java를 사용하면 다음과 같은 코드를 작성할 수 있습니다.

```java
List<String> result = new ArrayList<>();

for (Item item : result) {
    if (!test(item)) continue;
    result.add(item.ID);
}
```

Java 8에서는 Stream을 사용하면 `선언형`으로 명시적으로 표현이 가능합니다. 확실히 명령형보다, 선언형 코드가 가독성이 훨씬 좋음을 알 수 있습니다. 바로 이것이 함수형 프로그래밍이 지향하는 부분입니다. 
- 컬렉션을 이용한 로직의 경우 `어떻게`를 기술합니다.
- 스트림은 `무엇을` 해야 하는지 기술합니다.


```java
List<String> result = 
    items.stream()
        .filter(item -> test(item))
        .map(item -> item.ID)
        .collect(Collectors.toList());
```

## Java 8에서 새롭게 등장한 것

> 정말 많은 API 및 기능이 탄생했겠지만, 그 중에서 반드시 알고 있어야 한다고 생각하는 부분만 정리했습니다.


### NULL처리를 위한 명시적인 방법이 생겼다

기존 Java에서는 NULL 처리를 위한 명시적인 방법이 없었습니다. Java 8에서는 `Optional`이라는 객체를 활용해 NULL 처리를 위한 명시적인 방법을 제공합니다.

### 인터페이스 변경이 쉬워졌다

기존 Java는 인터페이스를 변경하기 매우 어려웠습니다. 하나의 인터페이스와 그 인터페이스를 구현하는 많은 수의 구현 클래스들이 묶여 있기 때문에, 인터페이스를 변경하려면 구현 클래스들 모두 변경해줘야 합니다.

Java 8은 `Default Method`를 통해 이 문제를 해결했습니다. 디폴트 메소드는 구현 클래스에서 구현하지 않아도 되는 특수한 메소드입니다. 따라서 디폴트 메소드를 사용하면, 인터페이스를 구현한 클래스와는 무관하게 확장할 수 있습니다.


## 마무리

이 책은 Java 8을 입문하기에 적절한 책이라는 느낌을 받았습니다. 적절한 예제를 통해 이해하기 쉬웠고, 또 내용 자체도 흥미로워 읽기 좋았습니다.

Java 8은 기존 Java와는 근본적으로 다른 부분들이 정말 많이 등장했습니다. 이 책을 읽은 후, 새로운 언어를 배우고 싶다는 생각이 많이 들었습니다. 특히 함수형 언어에 관심이 갑니다.

모든 기술들이 그렇듯, 그 기술을 사용할 때 주의할 점은 반드시 있습니다. 이 부분은 실제로 Java 8을 활용해보면서 차후 정리할 예정입니다. 

읽어주셔서 감사힙니다 :)