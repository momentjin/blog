복습할 겸 정렬 알고리즘에 대해 간단히 알아보았습니다.

개발하면서 가장 많이 접하는 알고리즘은 정렬이라고 감히 추측해봅니다. 어플리케이션 로직에도 정렬을 많이 사용하고, 데이터베이스의 인덱스나 쿼리에서도 정말 흔히 사용합니다. 이번 포스팅은 기억 속에 존재하는 정렬 알고리즘의 특징 들을 다시 한 번 정리하고, 잘 몰랐던 부분까지 학습하고자 작성했습니다. (참고로 정렬 알고리즘의 정의에 대해서는 따로 정리하지 않았습니다)

## 왜 정렬 알고리즘을 배워야할까?

대다수 언어의 표준 라이브러리는 최소 하나 이상의 정렬 알고리즘이 내장되어 있습니다. Java의 경우에도 Collections.sort()라는 함수가 제공됩니다. 라이브러리에서 제공해주는데 굳이 왜 정렬 알고리즘을 배워야 할까요? 정렬 알고리즘은 각각의 장단점이 분명히 존재하고, 모든 Case에 대해 최선의 결과를 내지 않기 때문입니다. 따라서 각 정렬 알고리즘에 대한 특징을 분명히 알아두고, 상황에 맞게 적절하게 사용할 수 있는 분별력이 필요하다고 생각합니다. 

## 정렬 알고리즘 선택을 위한 고려사항

### 정렬할 데이터의 양

정렬할 데이터에의 양에 따라 정렬 알고리즘의 실행 시간 차이가 큽니다. 따라서 정렬 알고리즘을 사용하는 코드에서 처리할 가능성이 있는 가장 큰 용량의 데이터에 대해서 처리할 수 있는 알고리즘을 선택해야 합니다.

### 데이터와 메모리

정렬할 데이터를 메모리에 모두 올려서 처리할 수 있는지 또는 나눠서 처리할 수 있는지 검토해야 합니다.

### 필요한 추가 메모리의 양

메모리가 부족할 때는 효율보다는 추가 메모리를 적게 쓸 수 있도록 적절한 알고리즘을 선택해야 합니다.

### 상대 위치 보존 여부

상대 위치 보존 여부란, 정렬할 대상 중 Key가 같은 값이 존재할 때 데이터 집합에 유지된 순서가 정렬 후에도 그대로 유지되는지 여부를 말합니다(이런 정렬 알고리즘을 Stable Sort라고 합니다). 만약 상대 위치 보존 여부가 필요하다면, 이를 검토해서 적절한 알고리즘을 선택해야 합니다.

## 정렬 알고리즘들의 특징을 분석해보자

### Selection Sort, Bubble Sort

정렬 대상의 정렬 여부가 성능에 영향을 미치지 않아, 시간복잡도는 항상 O(n^2)입니다. 효율이 좋지 않은 알고리즘입니다.

선택 정렬의 경우, 하나의 원소를 정렬하기 위해 데이터를 비교하는 횟수가 최대 N-1번 입니다. 만약 원소를 움직이는 비용이 비교작업에 비해 비싼 경우에는 선택 정렬이 다른 알고리즘보다 빠를 수도 있습니다.

### Insertion sort

정렬 대상이 이미 정렬되어 있을 경우, 시간복잡도는 O(n)이 된다. 따라서 새로운 원소를 추가하고 재정렬을 할 때 선형 시간의 복잡도를 갖기 때문에 효율적인 알고리즘이라고 할 수 있습니다.

### Quick sort

퀵 정렬은 Pivot에 따라 성능이 크게 좌우되는 알고리즘입니다. 가장 이상적인 Pivot은 전체 데이터를 절반씩 나눌 수 있는 값이다. 따라서 최선의 경우 시간 복잡도는 O(nlog(n))이 됩니다.

최악의 경우는 Pivot이 하필이면 데이터 집합 중 최소값인 경우입니다. Pivot을 기준으로 데이터들을 나눠봤자 왼쪽은 0개, 오른쪽은 n-1개로 나눠집니다. 따라서 항상 N-1번 재귀호출하므로 한 번 재귀호출할 때마다 시간복잡도는 O(n), 모든 원소에 대해서는 O(n^2)이 되며, 최선의 Pivot을 선택할 때보다 성능이 떨어집니다.

### Merge sort

병합 정렬은 다른 정렬 알고리즘에 비해 추가 메모리를 필요로 하기 때문에, 이를 주의해서 사용해야 합니다. 시간복잡도의 경우 항상 O(nlog(n))이기 때문에, 만약 정렬 시간을 칼같이 지켜야 한다면 병합 정렬을 선택하는 것이 적합해 보입니다.

## Quick sort vs Merge sort

병합 정렬은 어떤 경우에도 항상 O(nlog(n))의 시간 복잡도를 갖는다고 했는데, 여기서 아래와 같은 의문을 가져볼만 합니다.

`그럼 Merge sort는 Quick sort보다 좋은 알고리즘 아닌가? Quick sort는 최악의 경우에 O(n^2)이지만, Merge sort는 항상 O(n(log(n)))인데?`

저 역시 이 부분이 궁금했고, 검색한 결과 [관련 자료](https://stackoverflow.com/questions/70402/why-is-quicksort-better-than-mergesort)를 찾을 수 있었습니다. 간단히 요약해보면 프로세서가 메모리에 접근하는 위치의 정도인 `지역성`에 따른 성능 차이가 있기 때문에, 일반적으로 Quick sort가 더 빠르다고 합니다.

## 끝으로

비단 알고리즘 뿐만 아니라 어떤 무언가를 사용하려 할 때, 상황 및 조건을 따져보고 그에 맞게 적절한 선택을 해야합니다. 정렬 알고리즘의 경우에는 메모리, 데이터의 특징과 양, 순서 유지 여부 등 여러 가지 측면을 고려해서 알고리즘을 선택해야 한다는 사실을 배웠습니다.

## References

책 - 프로그래밍 면접, 이렇게 준비한다

구글신








