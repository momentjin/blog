JPA 사용시 주의점에 대해 정리한 글 입니다.

---

### @Transactional 묶음 처리는 의도대로 작동하지 않을 수 있다

#### 문제

동일한 Bean 내 @Transactional 부여된 메소드에서 다른 @Transactional 메소드를 호출했을 때, 트랜잭션이 묶이지 않는 문제가 있다. 

#### 해결

각 메소드를 별도의 Bean으로 분리한 뒤 호출하기 (사실 별개의 트랜잭션임에도 같은 클래스의 내부 메소드를 호출한다면, 해당 클래스가 담당하지 않아야 할 책임일 확률이 크다)

#### 참고
- https://cheese10yun.github.io/spring-transacion-same-bean/

---

### @ID의 IDENTITY 방식에서의 Bulk Insert

#### 문제

Entity의 Id 생성 전략이 IDENTITY인 경우, saveAll() 메소드로 Bulk Insert를 시도해도, 하이버네이트 내부적으로 삽입 1건당 하나의 트랜잭션으로 작동한다.

만일 1000건을 동시에 저장한다면, 1000개의 쿼리가 데이트베이스에 전송되는 것과 같다. 이는 측정하지 않아도, 오버헤드임에 틀림없다.

#### 해결

JPA가 아닌 다른 방법을 사용한다. (JDBC 등)

#### 참고

https://homoefficio.github.io/2020/01/25/Spring-Data%EC%97%90%EC%84%9C-Batch-Insert-%EC%B5%9C%EC%A0%81%ED%99%94/


---

### Spring Data JPA의 이름 기반 메소드 사용 자제하기

#### 문제

간단한 메소드의 경우 아래와 같이 개발자가 식별하기에 무리가 없다.
- Optional<Member> findByPhoneNum(String phoneNum);

하지만 아래와 같이 복잡한 쿼리의 경우 해당 쿼리가 정확히 어떤 역할을 하는지 식별하기 쉽지 않은 문제가 있다. (여기서는 고작 조건이 3개밖에 없지만, 실무의 경우 이보다 조건의 갯수가 훨씬 많은 경우도 분명 존재한다)

- List<Member> findAllByStatusAndCreatedAtAfterOrderByCreatedAtDesc

#### 해결

다음 3가지 방법을 활용하면 훨씬 가독성을 높일 수 있다.
- Named 쿼리 : SQL을 명시적으로 작성해서 가독성을 높일 수 있다.
- QueryDSL : SQL과 비슷한 효과. 단, 서브쿼리, 조인 등을 사용할시 복잡해질 수 있다.
- Specification : 조건에 대한 코드를 일일이 작성해야 한다는 부담이 있지만, 일단 한 번 만들어놓으면, 여러 조건을 조합해서 재활용할 수 있다는 장점이 있다.

그 외에도 Spring Data JDBC를 활용해 직접 SQL을 작성하는 방법이 있다. 방법은 무궁무진하다. Spring이라고 항상 JPA만 쓰라는 보장은 없다.

---

### OSIV (Open Session In View) 이해하고 사용하기

#### 문제

OSIV 옵션 사용하는 것이 좋을까?

OSIV를 사용할 때,
- 트랜잭션 없이 Controller에서 영속성 컨텍스트를 사용할 수 있다. -> Lazy 예외 발생 X
- 트랜잭션 없이 Controller에서 엔티티를 수정할 수 없다. 

OSIV를 사용하지 않으면,
- 트랜잭션 없이 Controller에서 영속성 컨텍스트를 사용할 수 없다. -> Lazy 예외 발생 O
- 트랜잭션 없이 Controller에서 엔티티를 수정할 수 없다. 

그렇다면, 언제 OSIV를 사용해야할까?

#### 해결 

이것은 단지 선택의 문제다. OSIV는 트랜잭션 없이도, 객체 그래프를 자유롭게 탐색할 수 있다는 장점이 있다. 따라서 글로벌 페치 전략, 강제 초기화, 페치 조인 등에 대해 신경쓰지 않아도 된다.

반면에 조회힐 데이터가 복잡한 경우, OSIV를 통해 객체그래프 사용을 남용하면 오히려 가독성이 떨어질 수도 있다. 
 
정답은 없고, 선택은 자유다. 상황에 맞는 적절한 방법을 채택하는 것이 베스트라고 생각한다.

> 나는 보통 Service Layer에서 엔티티를 직접 반환하고, OSIV 옵션을 활성화해서 간단한 연관 객체를 영속성 컨텍스트의 도움을 통해 조회한다. 반면에 조회할 데이터가 복잡한 경우, 한 번의 쿼리로 모든 데이터를 가져올 수 있도록 JPQL 등을 활용하는 편이다.

---

### @OrderColumn 사용하지 말기

#### 문제

기술의 득보다 실이 많은 경우의 대표적인 예시다. @OrderColumn을 사용하면 다음과 같은 문제가 발생한다.

- 1:N의 관계에서, 1에 해당하는 엔티티에 OrderColumn을 정하므로 N에 해당하는 엔티티만 단독으로 INSERT시 order값이 저장되지 않음
- i번째 위치한 데이터를 삭제하면, i+1 ~ (List.size)번까지 빈공간을 채우기 위해 X번의 업데이트 쿼리가 발생
- 데이터베이스에서 i번 데이터가 강제로 삭제된 경우, List 순회시 null 예외가 발생

위 단점들을 보면 JPA가 주체적으로 order를 관리하게 되며, 개발의 자유도가 많이 떨어진다.

#### 해결

이러한 경우, 직접 order 컬럼을 만들고 관리하는 편이 낫다. 


